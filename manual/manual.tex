\documentstyle{book}

\begin{document}

\chapter{Basic design}

2Geom is written using a functional programming style\cite{}.
Generally data structures are considered immutable and rather than
assignment we use labeling.  However, C++ can become unwieldly if this
is taken to extreme and so a certain amount of pragmatism is used in
practice.

The code relies strongly on the type system and uses some of the more
'tricky' elements of C++ to make the code more elegant.  However, as
the intended use of 2Geom is a serious vector graphics application,
where performance is still used as a quality metric, we consider
performance a bug and have traded elegance for efficiency where it
matters.

In general the data structures used in 2Geom are relatively 'flat' and
require little from the memory management.  Currently most data
structures are built on standard STL headers\cite{stl} and new and
delete are used sparingly.  It is intended for 2Geom to be fully
compatible with Boehm garbage collector\cite{boehm} though this has
not yet been tested.

\section{Points}

2Geom uses the term Point rather loosely from a mathematical
perspective.  Points are actually unbased vectors represented as a
two-ple for X and Y.  People often ask why 2Geom uses a 2 element
array rather than the more traditional \verb|struct| with \verb|.x|
and \verb|.y|.  We originally chose this representation after noting
the large number of copy and paste bugs introduced in code performing
calculations using \verb|.x| and \verb|.y|.

We found that code using .x and .y encouraged people to attempt to
inline geometry operations rather than using operators (perhaps
looking for a performance enhancement), and to try and optimise
operations (usually incorrectly).  By using a vector we encourage
people to think about Points as symmetrical objects and discourage
direct use of the components.  We still provide direct access for the
rare occasion that these are needed.

\section{Transformations}
\subsection{scale}
\subsection{rotate}
\subsection{translate}
\subsection{Matrix}

\section{Rect}

\section{ConvexHull}

\section{Path}



\section{SubPath}


we assume that paths are made from C0 continuous segments
(called Path::Element in 2geom)
because they are c0 continuous they can share endpoints
for storage we have two arrays: handles and commands
we assume that all commands define a segment using 'points', namely on canvas positions, and that affine transformation of the points will affine transform the segment
so to reconstruct the path we walk through handles and cmd in parallel, 'eating' enough points for each element
adding a handle without updating cmd would almost certainly make the path garbage.

this has the property of taking only slightly more memory than a sequence of points in the poly line or poly bezier case, but allows us lots of flexibility with what sort of elements we can 'understand'.

subpathops are 'line', 'quadratic bezier', 'cubic bezier', 'c-spline'

what is true is that affine transforming handles also affine transforms the path
and the convex hull of handles is the convex hull of the path

and the convex hull of element handles is the convex hull of the elements

\section{Location}

\section{Location sequences}

Many algorithms are more efficient on a sorted sequence of locations,
than calling the function repeatedly for each.  So we have algorithms
that take a sequence of locations, assumed in order, and perform an
action on those.  For example, cutting a path at one location is
basically linear in the number of path segments, but cutting a path in
10 locations is still about the same amount of work.  Similarly,
working out the arc length for a location is about the same amount of
work as working out the arc length for 1000 locations on that path.

Many operations are best described as returning an ordered set of
locations - for example, we have a function which returns
intersections between two paths.  rather than return just one
intersection, we might return all intersections, either in order along
the path, or in order of distance along other path.

Think about dashes: a dash is a fixed arclength offset.  So rather
than getting the location for a point at arc length 1, at arc length
2, 3, 4.. to the length of the curve, instead we just ask for all of
these, and the algorithm can chug along the curve outputting the
answer for each.  the reason it is faster is because to work out the
location at arc length say 100, we basically need to work out the
length for many spots up to 100.

Perhaps we then want to split the curve at each of those points.  To
split a segment at a location first requires finding that segment,
then spliting it and finally constructing a new path to output a whole
new path so we can fit the two new segments in.  If we started at the
begining, and split at the first location, that would be n+1 steps - n
segs in the original, plus an extra one.  If we wanted to split at 100
points, it would be n+1 steps for the first, n+2 for the
second... n+100 steps for the last, this would take a total of 100n +
100*101/2 steps!  Whereas, if we split as we went along, it would take
just n+100 steps.

The downside is that I'll probably not provide a separate split
routine that takes a single point, to discourage people from making
exactly that mistake.

\section{S power basis form}

2Geom provides a very powerful algebra for modifying paths.  Although
paths are kept in an extended SVG native form where possible, many
operations require approximation.  To do this we can convert a path
into a sequence of s-power basis polynomials, henceforth referred to
as s-basis, perform the required operations and convert back,
approximating to a requested tolerance as required.

The details of the s-basis form are beyond the scope of this manual,
the interested reader should consult \cite{SanchezReyes1997,SanchezReyes2000,SanchezReyes2001,SanchezReyes2003,SanchezReyes2004} for the details.

The most important properties of the s-basis form are:
\begin{itemize}
\item exact representation of bezier segments
\item fast conversion from all svg elements
\item basic arithmetic - $+$, $-$, $\times$, $\div$
\item algebraic derivative and integral
\item elementary trigonometric functions: $\sqrt{\cdot}$, $\sin(\cdot)$, $\cos(\cdot)$, $\exp(\cdot)$
\item efficient degree elevation and reduction
\item function inversion
\item recovery of exact solutions for many non trivial operations
\item strong convergence guarantees
\item low condition number on bezier conversion.
\item $C^0$ continuity guarantee
\end{itemize}

All these operations are fast.  For example, multiplication of two
beziers by converting to s-basis form, multiplying and converting back
takes roughly the same time as performing the bezier multiplication
directly, and further more, subdivision and degree reduction are
straightforward in this form.


\section{Acknowledgements and history}

2Geom is a group project, having many authors and contributors.  The
original code was sketched out by Nathan Hurst and Peter Moulder for
the Inkscape vector graphics program to provide well typed, correct
and easy to use C++ classes.  Since then many people have refined and
debugged the code.  One of the earliest C++ification projects for
inkscape was replacing NRPoint with NR::Point.

A conspicuous absence was a Path datatype, and indeed Inkscape
developed at least 3 different internal path datatypes, plus several
others in related projects.  Considering the core importance of path
operations in vector graphics this led to much reimplementation of
algorithms, numerous bugs and many round trips converting between
forms.

Many attempts were made to try and develop a single path data
structure, but all were fated to sit in random SCMs scattered across
the web.

Several unrelated projects had copied out various portions of the NR
code from Inkscape and 

In 2006 Mentalguy and Nathan felt it was time to separate out
the geometry portions of inkscape into a separate library for general
use.  the namespace was changed from NR to Geom and a prototype for
paths was sketched out.  Nathan studied the state of the art for
computational geometry whilst Mental focussed on the design of Paths.

Before the remerging of 2Geom with the inkscape svn HEAD it was felt
that a few smaller projects should be ported to use 2Geom.  Michael
Wybrow's libavoid advanced connector routing system was ported first.

--now.

\subsection{People who have contributed to 2Geom}

%alphabetical
Aaron C. Spike,
Fred (livarot),
Javier Sanchez-Reyes,
Jonathon Wright,
Joshua Blocher,
Kim Marriott,
Mentalguy,
Michael J. Wybrow,
Michael Sloan,
Nathan J. Hurst,
Peter J. R. Moulder

\end{document}