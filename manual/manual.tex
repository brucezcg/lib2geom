\documentstyle{book}

\begin{document}

\chapter{Basic design}

\section{Points}

\section{Transformations}
\subsection{scale}
\subsection{rotate}
\subsection{translate}
\subsection{Matrix}

\section{Rect}

\section{ConvexHull}

\section{Path}

\section{SubPath}

\section{Location}

\section{Location sequences}

Many algorithms are more efficient on a sorted sequence of locations,
than calling the function repeatedly for each.  So we have algorithms
that take a sequence of locations, assumed in order, and perform an
action on those.  For example, cutting a path at one location is
basically linear in the number of path segments, but cutting a path in
10 locations is still about the same amount of work.  Similarly,
working out the arc length for a location is about the same amount of
work as working out the arc length for 1000 locations on that path.

Many operations are best described as returning an ordered set of
locations - for example, we have a function which returns
intersections between two paths.  rather than return just one
intersection, we might return all intersections, either in order along
the path, or in order of distance along other path.

Think about dashes: a dash is a fixed arclength offset.  So rather
than getting the location for a point at arc length 1, at arc length
2, 3, 4.. to the length of the curve, instead we just ask for all of
these, and the algorithm can chug along the curve outputting the
answer for each.  the reason it is faster is because to work out the
location at arc length say 100, we basically need to work out the
length for many spots up to 100.

Perhaps we then want to split the curve at each of those points.  To
split a segment at a location first requires finding that segment,
then spliting it and finally constructing a new path to output a whole
new path so we can fit the two new segments in.  If we started at the
begining, and split at the first location, that would be n+1 steps - n
segs in the original, plus an extra one.  If we wanted to split at 100
points, it would be n+1 steps for the first, n+2 for the
second... n+100 steps for the last, this would take a total of 100n +
100*101/2 steps!  Whereas, if we split as we went along, it would take
just n+100 steps.

The downside is that I'll probably not provide a separate split
routine that takes a single point, to discourage people from making
exactly that mistake.

\section{S power basis form}

2Geom provides a very powerful algebra for modifying paths.  Although
paths are kept in an extended SVG native form where possible, many
operations require approximation.  To do this we can convert a path
into a sequence of s-power basis polynomials, henceforth referred to
as s-basis, perform the required operations and convert back,
approximating to a requested tolerance as required.

The details of the s-basis form are beyond the scope of this manual,
the interested reader should consult \cite{SanchezReyes1997,SanchezReyes2000,SanchezReyes2001,SanchezReyes2003,SanchezReyes2004} for the details.

The most important properties of the s-basis form are:
\begin{itemize}
\item exact representation of bezier segments
\item fast conversion from all svg elements
\item basic arithmetic - $+$, $-$, $\times$, $\div$
\item algebraic derivative and integral
\item elementary trigonometric functions: $\sqrt{\cdot}$, $\sin(\cdot)$, $\cos(\cdot)$, $\exp(\cdot)$
\item efficient degree elevation and reduction
\item function inversion
\item recovery of exact solutions for many non trivial operations
\item strong convergence guarantees
\item low condition number on bezier conversion.
\item $C^0$ continuity guarantee
\end{itemize}

All these operations are fast.  For example, multiplication of two
beziers by converting to s-basis form, multiplying and converting back
takes roughly the same time as performing the bezier multiplication
directly, and further more, subdivision and degree reduction are
straightforward in this form.


\end{document}