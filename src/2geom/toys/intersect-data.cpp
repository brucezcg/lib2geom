#include <iostream>
#include <2geom/path.h>
#include <2geom/svg-path-parser.h>
#include <2geom/path-intersection.h>
#include <2geom/basic-intersection.h>
#include <2geom/pathvector.h>
#include <2geom/exception.h>

#include <cstdlib>
#include <set>
#include <vector>
#include <algorithm>

#include <2geom/toys/path-cairo.h>
#include <2geom/toys/toy-framework-2.h>
#include <2geom/bezier-to-sbasis.h>
#include <2geom/ord.h>

#include "sweeper.cpp"

/*
IntersectionData is a bad choice of name to describe the topology of a given PathVector.

The strategy is to have the events generated by an external "sweeper", and just react to them.

The data mainly consists in 3 vectors: vertices, edges, and areas.
-edges: have start/end, left/right pointing to vertices or areas.
-vertices: have a "boundary"= the sequence of edges sorted in CCW order.
-areas: have an outer "boundary" + a vector of inner boundaries.

At creation time, the data calls a sweeper, creates one edge with unkown start/end/left/right
for each sweeper tile, and one empty area.

The data is filled according to the events. It is supposed to stay well formed all along the process:
at each time, the data represents the topology of everything before the sweepline (you can 
imagine that the edges are prolongated to infinity without crossing after they cross the sweepline).

The only exception is that during a sequence of events representign one big event, a virtual edge
should be added at the end the vertex boundary to represent the crossing of the box (it should be
 removed at the end of the sequence, and is useless, so it's not added at all).


The code is using a lot of vectors: unsing pointers instead of vectors could speed things up,
but vector indices are easier to debug than memory addresses.:P
*/

using namespace Geom;
using namespace std;

class IntersectionData {
public:

    // -!- convention: 
    // I a boundary, reversed edges point away from the vertex or CW around the area.
    struct OrientedEdge{
        unsigned edge; //edge index.
        bool reversed; //true if the intrinsic edge orientation points away (from vertex) or backward (along area boundary)
        OrientedEdge(unsigned edge_idx, bool o){
            edge = edge_idx;
            reversed = o;
        }
        OrientedEdge(){
            edge = NULL_IDX;
            reversed = false;
        }
        bool operator == ( OrientedEdge const &other) const {
            return (edge == other.edge && edge!=NULL_IDX && reversed == other.reversed);
        }
    };

    class Boundary : public std::vector<OrientedEdge>{
    public:
        //debug only:
        bool of_area;//true if this the boundary of an area. Fix this with templates?
        Boundary(bool area_type): of_area(area_type){}
    };

    class Vertex{
    public:
        Boundary boundary; // pairs of (edge,area) indices
        Geom::Rect bounds;
        Vertex():boundary(false){}
    };
    
    class Area {//an area is a connected comp of the complement of the graph.  .
    public:
        Boundary boundary; // pairs of (edge,vertex) indices in the outermost component
        std::vector<Boundary> inner_boundaries;
        std::vector<int> windings;
        Area(unsigned size):windings(size, 0), boundary(true){}
    };

    class Edge {
    public:
        unsigned left, right;// the area indices of the left and right areas of this curve
        unsigned start, end; // the vertex indices of start and end.(redundant, but keeps duality between pt and areas...)
        Geom::Interval portion;
        unsigned path;
        unsigned curve;
        Edge(){
            left = NULL_IDX;
            right =NULL_IDX;
            start = NULL_IDX;
            end = NULL_IDX;
            portion = Interval();
            path = NULL_IDX;
            curve = NULL_IDX;
        }
    };

    vector<Area> areas;
    vector<Edge> edges;
    vector<Vertex> vertices;
    
    PathVector input_paths;//we don't need our own copy...
    cairo_t* cr;

    //----------------------------------------------------
    //-- utils...
    //----------------------------------------------------

    void printIdx(unsigned idx){ (idx == NULL_IDX)? std::printf("?") : std::printf("%u", idx); }
    void printVertex(unsigned i){
        std::printf("vertex %u: ", i);
        printBoundary(vertices[i].boundary);
        std::printf("\n");
        }
    void printEdge(unsigned i){
        std::printf("edge %u: ", i);
        printIdx(edges[i].start);
        std::printf(" -> ");
        printIdx(edges[i].end);
        std::printf(" ^");
        printIdx(edges[i].left);
        std::printf(" _");
        printIdx(edges[i].right);
        std::printf("\n");
        }
    void printArea(unsigned i){
        std::printf("area %u: ", i);
        printBoundary(areas[i].boundary);
        for (unsigned j=0; j<areas[i].inner_boundaries.size(); j++){
            std::printf(", ");
            printBoundary(areas[i].inner_boundaries[j]);
        }
        std::printf("\n");
    }

    void printOrientedEdge(OrientedEdge const &f){
        ( f.reversed ) ? std::printf("-") : std::printf("+");
        printIdx(f.edge);
        std::printf(" ");
    }
    void printBoundary(Boundary const &bndry){
        (bndry.of_area) ? std::printf("[") : std::printf("<");
        for (unsigned i=0; i<bndry.size(); i++){
            printOrientedEdge(bndry[i]);
        }
        (bndry.of_area) ? std::printf("]") : std::printf(">");
    }

    void print(){
        std::cout<<"\nCrossing Data:\n";
        for (unsigned i=0; i<vertices.size(); i++){
            printVertex(i);
        }
        std::cout<<"\n";
        for (unsigned i=0; i<edges.size(); i++){
            printEdge(i);
        }
        std::cout<<"\n";
        for (unsigned i=0; i<areas.size(); i++){
            printArea(i);
        }
    }

    //----------------------------------------------------
    //-- Boundary Navigation/Modification
    //----------------------------------------------------

    //TODO: this should be an OrientedEdge method, be requires access to the edges.
    unsigned source(OrientedEdge const &f, bool as_area_bndry){
        unsigned prev;
        if (f.reversed )
            prev = (as_area_bndry)? edges[f.edge].end : edges[f.edge].right;
        else
            prev = (as_area_bndry)? edges[f.edge].start : edges[f.edge].left;
        return prev;
    }
    unsigned target(OrientedEdge const &f, bool as_area_bndry){
        unsigned prev;
        if (f.reversed )
            prev = (as_area_bndry)? edges[f.edge].start : edges[f.edge].left;
        else
            prev = (as_area_bndry)? edges[f.edge].end : edges[f.edge].right;
        return prev;
    }

    //TODO: this should be a Boundary method, but access to the full data is required...
    bool prolongate( Boundary &bndry, OrientedEdge const &f){
        if ( bndry.empty() ){
            bndry.push_back(f);
            return true;
        }        
        unsigned src = source(f, bndry.of_area);
        if ( src == target( bndry.back(),  bndry.of_area ) && src != NULL_IDX ){
            bndry.push_back(f);
            return true;
        }
        unsigned tgt = target( f, bndry.of_area );
        if ( tgt == source( bndry.front(), bndry.of_area ) && tgt != NULL_IDX ){
            bndry.insert( bndry.begin(), f);
            return true;
        }
        return false;
    }

    bool prolongate(Boundary &a, Boundary &b){
        if (a.size()==0 || b.size()==0 || (a.of_area != b.of_area) ) return false;
        unsigned src;
        src = source(a.front(), a.of_area);

        unsigned af = a.front().edge, as=source(a.front(), a.of_area), ab=a.back().edge, at=target(a.back(), a.of_area);
        unsigned bf = b.front().edge, bs=source(b.front(), b.of_area), bb=b.back().edge, bt=target(b.back(), b.of_area);
//        std::printf("a=%u(%u)...(%u)%u\n", as, af,ab,at);
//        std::printf("b=%u(%u)...(%u)%u\n", bs, bf,bb,bt);

//        std::printf("%u == %u?\n", src, target( b.back(), b.of_area ));
        if ( src == target( b.back(), b.of_area ) && src != NULL_IDX ){
            a.insert( a.begin(), b.begin(), b.end() );
//            std::printf("boundaries fused!!\n");
            return true;
        }
        src = source(b.front(), b.of_area);
        if ( src == target( a.back(), a.of_area ) && src != NULL_IDX ){
            a.insert( a.end(), b.begin(), b.end() );
            return true;
        }
        return false;
    }

    //TODO: this should be a Boundary or Area method, but requires access to the full data...
    //TODO: systematically check for connected boundaries before returning?
    void addAreaBoundaryPiece(unsigned a, OrientedEdge const &f){
        if ( areas[a].boundary.size()>0 && prolongate( areas[a].boundary, f ) ) return;
        for ( unsigned i=0; i<areas[a].inner_boundaries.size(); i++){
//            printBoundary(areas[a].inner_boundaries[i]);
//            printf(" matches ");
//            printOrientedEdge(f);
//            printf("?");
            if ( areas[a].inner_boundaries[i].size()>0 && prolongate( areas[a].inner_boundaries[i], f) ) return;
//            printf("no. (%u vs %u)", target(areas[a].inner_boundaries[i].back(), true), source(f, true));
        }
        Boundary new_comp(true);
        new_comp.push_back(f);
        areas[a].inner_boundaries.push_back(new_comp);
    }


    bool fuseConnectedBoundaries(unsigned a){
//        std::printf(" fuseConnectedBoundaries %u\n",a);
        
        bool ret = false;
        if ( areas[a].boundary.size()>0 ){
            for ( unsigned i=0; i<areas[a].inner_boundaries.size(); i++){
                if ( prolongate( areas[a].boundary, areas[a].inner_boundaries[i] ) ){
                    areas[a].inner_boundaries.erase(areas[a].inner_boundaries.begin()+i);
                    i--;
                    ret = true;
                }
            }
        }
        for ( unsigned i=0; i<areas[a].inner_boundaries.size(); i++){
            for ( unsigned j=i+1; j<areas[a].inner_boundaries.size(); j++){
                if ( prolongate( areas[a].inner_boundaries[i], areas[a].inner_boundaries[j] ) ){
                    areas[a].inner_boundaries.erase(areas[a].inner_boundaries.begin()+j);
                    j--;
                    ret = true;
                }
            }
        }
        return ret;
    }
    
    //-------------------------------
    //-- Some basic area manipulation.
    //-------------------------------

    void renameArea(unsigned oldi, unsigned newi){
        for (unsigned e=0; e<edges.size(); e++){
            if ( edges[e].left  == oldi ) edges[e].left  = newi;
            if ( edges[e].right == oldi ) edges[e].right = newi;
        }
    }
    void deleteArea(unsigned a0){//ptrs would definitely be helpful here...
        assert(a0<areas.size());
        for (unsigned a=a0+1; a<areas.size(); a++){
            renameArea(a,a-1);
        }
        areas.erase(areas.begin()+a0);
    }

    //fuse open(=not finished!) areas. The boundaries are supposed to match. true on success.
    void fuseAreas(unsigned a, unsigned b){
//        std::printf("fuse Areas %u and %u\n", a, b);
        if (a==b) return;
        if (a>b) swap(a,b);//this is important to keep track of the outermost component!!

        areas[a].inner_boundaries.push_back(areas[b].boundary);
        for (unsigned i=0; i<areas[b].inner_boundaries.size(); i++){
            areas[a].inner_boundaries.push_back(areas[b].inner_boundaries[i]);
        }
        renameArea(b,a);
        deleteArea(b);
        assert( fuseConnectedBoundaries(a) );
        return;
    }

    D2<SBasis> edgeAsSBasis(unsigned e){
        //beurk! optimize me.
        D2<SBasis> c = input_paths[edges[e].path][edges[e].curve].toSBasis();
        return portion(c, edges[e].portion); 
    }


    //----------------------------------------------------
    //-- Fill data using a sweeper...
    //----------------------------------------------------

    IntersectionData(){}
    ~IntersectionData(){}
    IntersectionData(PathVector const &paths, double tol=EPSILON){
        std::printf("\n---------------------\n---------------------\n---------------------\n");
        std::printf("IntersectionData creation\n");        
        input_paths = paths;

        vertices.clear();
        edges.clear();
        areas.clear();
        Area empty( input_paths.size() );
        areas.push_back(empty);

        Sweeper sweeper( paths, X, tol );

        edges = std::vector<Edge>( sweeper.tiles_data.size(), Edge() );
        for (unsigned i=0; i<edges.size(); i++){
            edges[i].path = sweeper.tiles_data[i].path;
            edges[i].curve = sweeper.tiles_data[i].curve;
            edges[i].portion = Interval(sweeper.tiles_data[i].f, sweeper.tiles_data[i].t);
        }

        //std::printf("entering event loop:\n");        

        for(Sweeper::Event event = sweeper.getNextEvent(); ; event = sweeper.getNextEvent() ){
            if (event.empty()){
                //std::printf("   empty event recieved\n");        
                break;
            }
            //std::printf("   non empty event recieved:");
            //sweeper.printEvent(event);

            //is this a new event or the continuation of an old one?
            unsigned v;
            Rect r = sweeper.context.pending_vertex; 
            if (vertices.empty() || !r.intersects( vertices.back().bounds ) ){
                v = vertices.size();
                vertices.push_back(Vertex());
                vertices[v].bounds = r;
                //std::printf("   new intersection created (%u).\n",v);
            }else{
                v = vertices.size()-1;
                //std::printf("   continue last intersection (%u).\n",v);
            }
                
            //--Closing an edge:-------------
            if( !event.opening ){
                unsigned e = event.tile, a, b;
                //std::printf("   closing edge %u\n", e);        
                bool reversed = sweeper.tiles_data[e].reversed;//Warning: true means v==e.start
                if (reversed){
                    edges[e].start = v;
                    a = edges[e].right;
                    b = edges[e].left;
                }else{
                    edges[e].end = v;
                    a = edges[e].left;
                    b = edges[e].right;
                }
                OrientedEdge vert_edge(e, reversed);
                if (vertices[v].boundary.size()>0){//Make sure areas are compatible (only relevant if the last event was an opening).
                    fuseAreas ( a, target( vertices[v].boundary.back(), false ) );
                }
                assert( prolongate( vertices[v].boundary, vert_edge) );
                fuseConnectedBoundaries(a);//there is no doing both: tests are performed twice but for 2 areas.
                fuseConnectedBoundaries(b);//
            }else{
            //--Opening an edge:-------------
                unsigned e = event.tile, a, b;
                bool reversed = !sweeper.tiles_data[e].reversed;//Warning: true means v==start.
             
                //--Find first and last area around this vertex:-------------
                unsigned cur_a;
                if ( vertices[v].boundary.size() > 0 ){
                    cur_a = target( vertices[v].boundary.back(), false );
                }else{//this vertex is empty
                    if (event.insert_at>0){
                        unsigned lower_e = sweeper.context[event.insert_at -1];
                        cur_a = (sweeper.tiles_data[lower_e].reversed) ? edges[lower_e].right : edges[lower_e].left;
                    }else{
                        cur_a = 0;
                    }
                }

                unsigned new_a = areas.size();

                Area new_area(paths.size());
                new_area.boundary.push_back( OrientedEdge(e, !reversed ) );
                new_area.windings = areas[cur_a].windings;//FIXME: escape boundary cases!!!
                new_area.windings[edges[e].path] += (reversed) ? +1 : -1;
                areas.push_back(new_area);

                //update edge
                if (reversed){
                    edges[e].start = v;
                    edges[e].left = new_a;
                    edges[e].right = cur_a;
                }else{
                    edges[e].end = v;
                    edges[e].left = cur_a;
                    edges[e].right = new_a;
                }
                //update vertex
                OrientedEdge f(e, reversed);
                assert( prolongate( vertices[v].boundary, f) );
                addAreaBoundaryPiece(cur_a, OrientedEdge(e, reversed) );                
            }
            if (!event.to_be_continued && vertices[v].boundary.size()>0){
                unsigned first_a = source( vertices[v].boundary.front(), false );
                unsigned last_a = target( vertices[v].boundary.back(), false );
                fuseAreas(first_a, last_a);
            }

//            this->print();
//            std::printf("----------------\n"); 
            //std::printf("\n");
        }
    }


    
    //----------------------------------------------------
    //-- done.
    //----------------------------------------------------
};



class IntersectDataTester: public Toy {
    unsigned nb_paths;
    unsigned nb_curves_per_path;
    unsigned degree;
    double tol;

    std::vector<PointSetHandle> paths_handles;
    std::vector<Slider> sliders;
    IntersectionData topo;

    void drawAreas( cairo_t *cr, IntersectionData const &topo, bool fill=true ){
        for (unsigned a=0; a<topo.areas.size(); a++){
            drawArea(cr, topo, a, fill);
        }
    }
    void drawArea( cairo_t *cr, IntersectionData const &topo, unsigned a, bool fill=true ){
        if (a>=topo.areas.size()) return;
        Path bndary = Path();
        for (unsigned i = 0; i < topo.areas[a].boundary.size(); i++){
            unsigned eidx = topo.areas[a].boundary[i].edge;
            IntersectionData::Edge e = topo.edges[eidx];
            D2<SBasis> p = topo.input_paths[e.path][e.curve].toSBasis();
            Interval dom = e.portion;
            p = portion(p, dom);
            if (topo.areas[a].boundary[i].reversed){
                p = compose( p, Linear(1.,0.) );
            }else{
            }
            bndary.append(p, Path::STITCH_DISCONTINUOUS);
        }

        for (unsigned j = 0; j < topo.areas[a].inner_boundaries.size(); j++){
            for (unsigned i = 0; i < topo.areas[a].inner_boundaries[j].size(); i++){
                unsigned eidx = topo.areas[a].inner_boundaries[j][i].edge;
                IntersectionData::Edge e = topo.edges[eidx];
                D2<SBasis> p = topo.input_paths[e.path][e.curve].toSBasis();
                Interval dom = e.portion;
                p = portion(p, dom);
                if (topo.areas[a].inner_boundaries[j][i].reversed){
                    p = compose( p, Linear(1.,0.) );
                }
                bndary.append(p, Path::STITCH_DISCONTINUOUS);
            }
        }

        bndary.close();
        cairo_path(cr, bndary);
        double r,g,b;

        int winding = 0;
        for (unsigned k=0; k<topo.areas[a].windings.size(); k++){
            winding += topo.areas[a].windings[k];
        }

        //convertHSVtoRGB(0, 1., .5 + winding/10, r,g,b);
        //convertHSVtoRGB(360*a/topo.areas.size(), 1., .5, r,g,b);
        convertHSVtoRGB(180+30*winding, 1., .5, r,g,b);
        cairo_set_source_rgba (cr, r, g, b, .5);
        //cairo_set_source_rgba (cr, 1., 0., 1., .3);

        if (fill){
            cairo_fill(cr);
        }else{
            cairo_set_line_width (cr, 5);
            cairo_stroke(cr);
        }
    }

    void highlightRay( cairo_t *cr, IntersectionData &topo, unsigned b, unsigned r ){
        if (b>=topo.vertices.size()) return;
        if (r>=topo.vertices[b].boundary.size()) return;
        Rect box = topo.vertices[b].bounds;
        //box.expandBy(2);
        cairo_rectangle(cr, box);
        cairo_set_source_rgba (cr, 1., 0., 0, 1);
        cairo_set_line_width (cr, 1);
        cairo_fill(cr);
        unsigned eidx = topo.vertices[b].boundary[r].edge;
        IntersectionData::Edge e = topo.edges[eidx];
        D2<SBasis> p = topo.input_paths[e.path][e.curve].toSBasis();
        Interval dom = e.portion;
        if (topo.vertices[b].boundary[r].reversed){
            //dom[0] += e.portion.extent()*2./3;
            cairo_set_source_rgba (cr, 0., 1., 0., 1);
        }else{
            //dom[1] -= e.portion.extent()*2./3;
            cairo_set_source_rgba (cr, 0., 0., 1., 1);
        }
        p = portion(p, dom);
        cairo_d2_sb(cr, p);
        cairo_set_source_rgba (cr, 1., 0., 0, 1);
        cairo_set_line_width (cr, 5);
        cairo_stroke(cr);
    }

    void drawBox( cairo_t *cr, IntersectionData const &topo, unsigned b ){
        if (b>=topo.vertices.size()) return;
        Rect box = topo.vertices[b].bounds;
        //box.expandBy(5);
        cairo_rectangle(cr, box);
        cairo_set_source_rgba (cr, 1., 0., 0, 1);
        cairo_set_line_width (cr, 1);
        cairo_stroke(cr);

        //std::cout<<"\nintersection boundary:\n";
        for (unsigned i = 0; i < topo.vertices[b].boundary.size(); i++){
            unsigned eidx = topo.vertices[b].boundary[i].edge;
            IntersectionData::Edge e = topo.edges[eidx];
            D2<SBasis> p = topo.input_paths[e.path][e.curve].toSBasis();
            Interval dom = e.portion;
            if (topo.vertices[b].boundary[i].reversed){
                dom[0] += e.portion.extent()*2./3;
                cairo_set_source_rgba (cr, 0., 1., .5, 1);
            }else{
                dom[1] -= e.portion.extent()*2./3;
                cairo_set_source_rgba (cr, 0., .5, 1., 1);
            }
            p = portion(p, dom);
            cairo_d2_sb(cr, p);
            cairo_set_line_width (cr, 2);
            cairo_stroke(cr);
        }
    }
    void drawBoxes( cairo_t *cr, IntersectionData const &topo ){
        for (unsigned b=0; b<topo.vertices.size(); b++){
            drawBox(cr, topo, b);
        }
    }

    virtual void draw(cairo_t *cr, std::ostringstream *notify, int width, int height, bool save, std::ostringstream *timer_stream) {
        *notify<<"line command args: #1=nb paths, #2=nb csurves per path, #3=degree of each curve.\n";
        *notify<<"N.B.: first area is 'inverted' (it's the unbounded one)\n";
        *notify<<"N.B.: I dunno how to fill regions with holes :-(\n";
        cairo_set_source_rgba (cr, 0., 0., 0, 1);
        cairo_set_line_width (cr, 1);
        
        std::vector<Path> paths(nb_paths, Path());
        for (unsigned i = 0; i < nb_paths; i++){
            paths[i] = Path(paths_handles[i].pts[0]);
            for (unsigned j = 0; j+degree < paths_handles[i].size(); j+=degree){
                D2<SBasis> c = handles_to_sbasis(paths_handles[i].pts.begin()+j, degree);
                if ( j + degree == paths_handles[i].size()-1 ){
                    c[X].at(0)[1] = paths_handles[i].pts.front()[X];
                    c[Y].at(0)[1] = paths_handles[i].pts.front()[Y];
                }
                paths[i].append(c);
            }
            paths[i].close();
        }
        
        cairo_path(cr, paths);
        cairo_set_source_rgba (cr, 0., 0., 0, 1);
        cairo_set_line_width (cr, 1);
        cairo_stroke(cr);

        tol = 1.0;
        //IntersectionData topo;
        topo = IntersectionData(paths, tol);

#if 1
        unsigned v = (unsigned)(sliders[0].value()*(topo.vertices.size()));
        unsigned r = (unsigned)(sliders[1].value()*(topo.vertices[v].boundary.size()-1));
        unsigned a = (unsigned)(sliders[2].value()*(topo.areas.size()-1));
        if( v == topo.vertices.size() ) v--;
        if( r == topo.vertices[v].boundary.size()) r--;
        if( a == topo.areas.size()) a--;
        drawAreas(cr, topo);
        drawArea(cr, topo, a, false);
        highlightRay(cr, topo, v, r );

        //drawBox(cr,topo, unsigned(sliders[0].value()));
        drawBoxes(cr,topo);
#endif
        Toy::draw(cr, notify, width, height, save, timer_stream);
    }

    public:
    IntersectDataTester(unsigned paths, unsigned curves_in_path, unsigned degree) :
        nb_paths(paths), nb_curves_per_path(curves_in_path), degree(degree) {
        for (unsigned i = 0; i < nb_paths; i++){
            paths_handles.push_back(PointSetHandle());
        }
        for(unsigned i = 0; i < nb_paths; i++){
            for(unsigned j = 0; j < (nb_curves_per_path*degree)+1; j++){
                paths_handles[i].push_back(uniform()*400, 100+ uniform()*300);
            }
            handles.push_back(&paths_handles[i]);
        }
        sliders.push_back(Slider(0.0, 1, 0, 0.0, "intersection chooser"));
        sliders.push_back(Slider(0.0, 1, 0, 0.0, "ray chooser"));
        sliders.push_back(Slider(0.0, 1, 0, 0.0, "area chooser"));
        handles.push_back(&(sliders[0]));
        handles.push_back(&(sliders[1]));
        handles.push_back(&(sliders[2]));
        sliders[0].geometry(Point(50, 20), 250);
        sliders[1].geometry(Point(50, 50), 250);
        sliders[2].geometry(Point(50, 80), 250);
    }

    void first_time(int argc, char** argv) {

    }
};

int main(int argc, char **argv) {
    unsigned paths=10;
    unsigned curves_in_path=3;
    unsigned degree=1;
    if(argc > 3)
        sscanf(argv[3], "%d", &degree);
    if(argc > 2)
        sscanf(argv[2], "%d", &curves_in_path);
    if(argc > 1)
        sscanf(argv[1], "%d", &paths);
    if (degree<=0) degree = 1;
    if (curves_in_path<=0) curves_in_path = 3;
    if (paths<=0) paths = 1;
    init(argc, argv, new IntersectDataTester(paths, curves_in_path, degree));
    return 0;
}

/*
  Local Variables:
  mode:c++
  c-file-style:"stroustrup"
  c-file-offsets:((innamespace . 0)(inline-open . 0)(case-label . +))
  indent-tabs-mode:nil
  fill-column:99
  End:
*/
// vim: filetype=cpp:expandtab:shiftwidth=4:tabstop=4:softtabstop=4:encoding=utf-8:textwidth=99 :
